<!DOCTYPE HTML>
<!--
	Dopetrope by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Modern C++ design</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="stylesheet" href="assets/css/my.css" />
	<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
	<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>

	<!--
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	-->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>


	<link href="assets/css/prism.css" rel="stylesheet" />
	<script src="assets/js/prism.js"></script>


</head>

<body class="no-sidebar">
	<div id="page-wrapper">

		<!-- Header -->
		<div id="header-wrapper">
			<div id="header">

				<!-- Logo -->
				<h1>Modern C++ design</h1>

				<!-- Nav -->
				<!--<nav id="nav">-->
				<nav id="nav">
					<ul>
						<li><a href="index.html"><i class="fas fa-arrow-left"></i> Home</a></li>
					</ul>
				</nav>

			</div>
		</div>

		<!-- Main -->
		<div id="main-wrapper">
			<div class="container">


				<!-- Content -->
				<article class="box post">
					<!--<a href="#" class="image featured"><img src="images/pic01.jpg" alt="" /></a>-->

					<section>
						<header>
							<h2>Overview</h2>
						</header>

						<h3><a class="construction">&emsp;This page is under construction&emsp;</a></h3>
						<p>
							I update it regularly. I am currently looking for the best way to present the results. Feel free to come back later to access new content.
						</p>
						<h3>​Motivation</h3>
						<p>
							This project was born of a desire to improve in modern C ++ and to update my skills for the latest revisions of the standard (C++ 14 & 17). I was not satisfied by the so-called “advanced” courses available online, which often just superficially explain the language's features. So I suggested to one of my friends who is a cpp-passionate to do a more relevant and advanced course, which he accepted with joy.
							</p>
						<h3>How did it go?</h3>
						<p>
							We were 3 to 5 people to take this class every week. The content was mainly given orally, based on the written course and on godbolt to study the result of the compilation. The original course written by Sidney Congard is available in French on cours-cpp.gitbook.io/resources/. This page contains the statements of the challenges and the solutions I propose (soon available).
							</p>
					</section>
					<section>
						<header>
							<h2>Challenges</h2>
						</header>
							<h3>​tagged_ptr<!--**--></h3>
								<!--h4>Exercise</h4-->
									Write a covariant class <code class="language-cpp">tagged_ptr&lt;T></code> that can store and manipulate a counter inside a pointer of type <code class="language-cpp">T*</code>.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">// This function changes the object pointed to by ptr and increments its counter.
// The old value of the counter is returned.
int actualize(tagged_ptr&lt;T>& ptr, T const& value) {
    static_assert(sizeof(T*) == sizeof(ptr));
    int counter = ptr.get_counter();
    *ptr = value;
    ptr.increment_counter();
    return counter;
}</code></pre>


							<!--h4>Proposed solution</h4-->
							<p>
								<!--
								<details>
									<summary>
										Expand
									</summary>

<pre class="line-numbers"><code class="language-cpp">//Solution de side
#include &lt;cstdint>
#include &lt;cstddef>
#include &lt;type_traits>

// Cette solution stocke le compteur à l'intérieur de l'alignement du pointeur : par exemple,
// un pointeur vers un int doit avoir une adresse alignée sur 4 octets, donc on dispose
// d'autant de bits pour le compteur.
// Une autre solution (moins portable) aurait été d'utiliser les 16 premiers bits du pointeurs,
// inutilisés sur les architectures actuelles 64 bits.

// Utilitaires bonus :

// is_power_of_two sert à vérifier à la compilation que l'alignement du pointeur est valable,
// c'est-à-dire une puissance de 2.

template &lt;int I>
constexpr bool is_power_of_two = [] {
    if constexpr (I == 1) {
        return true;
    }
    else {
        constexpr int div = I / 2;
        if constexpr (div * 2 == I) {
            return is_power_of_two&lt;div>;
        }
        else return false;
    }
}();

// offset_between est utilisé pour implémenter la covariance : le pointeur tagué est incrémenté
// de cet offset pour qu'il pointe vers la classe mère souhaitée.

template &lt;class Base, class Derived>
constexpr int offset_between() {
    static_assert(std::is_base_of_v&lt;Base, Derived>);
    intptr_t d = 1;
    auto ptr = reinterpret_cast&lt;Derived*>(d);
    auto ptr2 = static_cast&lt;Base*>(ptr);
    auto b = reinterpret_cast&lt;intptr_t>(ptr2);
    return b - d;
}

// La classe permet de spécifier un plus grand alignement que celui par défaut pour le type T.

template &lt;class T, size_t Align = alignof(T)>
class tagged_ptr {
    template &lt;class T2, size_t A2>
    friend class tagged_ptr;
public:
    // Vérification de l'alignement à la compilation.
    static_assert(is_power_of_two&lt;Align>, "Alignment is not a power of two");
    static_assert(Align >= alignof(T),    "Alignement is too small for T");
    static_assert(Align > 1,              "No place to store the counter");

    static constexpr int max_counter = Align - 1;

    // Le constructeur commun est appelé pour initialiser la valeur du pointeur.
    // Il est sélectionné par 'tag dispatch', grâce à 'common_ctor_t' (défini plus bas).
    tagged_ptr() noexcept     : tagged_ptr(common_ctor_t{}, 0) {}
    tagged_ptr(T* p) noexcept : tagged_ptr(common_ctor_t{}, reinterpret_cast&lt;uintptr_t>(p)) {}

    tagged_ptr(tagged_ptr const&) = default;

    // La covariance est permise grâce à ce constructeur qui est à des pointeurs d'une classe
    // dérivée d'être changés en des pointeurs d'une de leur classe mère.
    // Note : le constructeur peut être plus général si on permet à l'alignement du pointeur
    // de changer.
    template &lt;class Derived, class = std::enable_if_t<
        std::is_base_of_v&lt;T, Derived>
    >>
    tagged_ptr(tagged_ptr&lt;Derived, Align> p) : tagged_ptr(
        common_ctor_t{},
        p.value + offset_between&lt;T, Derived>()) {}

    tagged_ptr& operator=(tagged_ptr const&) = default;

    // L'assignement covaraint (de derived vers base).
    template &lt;class Derived, class = std::enable_if_t<
        std::is_base_of_v&lt;T, Derived>
    >>
    tagged_ptr& operator=(tagged_ptr&lt;Derived, Align> p) {
        value = p.value + offset_between&lt;T, Derived>();
        return *this;
    }

    // Fonction manipulant le compteur.
    int get_counter()       const noexcept { return value & max_counter; }
    void set_counter(int counter) noexcept { value = pointer() + counter & max_counter; }
    void increment_counter()      noexcept { static_cast&lt;void>(++value & max_counter); }

    // Fonctions permettant d'accéder au pointeur.
    T* ptr()        const noexcept { return reinterpret_cast&lt;T*>(pointer()); }
    T* operator->() const noexcept { return ptr(); }
    T& operator&()  const noexcept { return *ptr(); }
private:
    uintptr_t value;

    struct common_ctor_t {};
    tagged_ptr(common_ctor_t, uintptr_t value) noexcept : value(value) {}

    uintptr_t pointer() const noexcept { return value & ~max_counter; }
};
</code></pre>
</details> -->
</p>

							<h3>to_string<!--***--></h3>
								<!--h4>Exercise</h4-->
									Write a template function <code class = "language-cpp">to_string(T const& value)</code> which allows to display different types (numbers, collections, tuples or even aggregates).<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">std::map&lt;int, std::string> keywords = {
    { 42, "Cluster" },
    { -1, "Hello World" },
    { 18, "Vaccin" }
};
// string = "[ { -1, Hello World }, { 18, Vaccin }, { 42, Cluster } ]"
auto string = to_string(keywords);
</code></pre>

								<!--h4>Proposed solution</h4-->
								<p></p>
							<h3>force_move<!--**--></h3>
								<!--h4>Exercise</h4-->
									Write <code class = "language-cpp">force_move(value)</code> which will cast the object to <em>prvalue</em> (as <code class = "language-cpp">std::move</code>) or run a compilation error if the object is <em>const</em>.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">MyClass global;
​
void create_global_by_move() {
    MyClass v1;
    // Equivalent to
    global = std::move(v1);
    global = force_move(v1);
​
    MyClass const v2;
    // The copy constructor will be called.
    // force_move stops the compilation to avoid confusion.
    global = std::move(v2);
    //global = force_move(v2);
}
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>unique_function<!--***--></h3>
								<!--h4>Exercise</h4-->
									Write a template class <code class = "language-cpp">unique_function&lt;T(Args...)></code> that allows you to manipulate any <em>function object</em> that can be <em>move</em>, similar to <code class = "language-cpp">std::function&lt;T(Args...)></code>, and implement the <em>Small Buffer Optimization</em>.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">// Returns a random number generator.
// The lambda catches a std::unique_ptr, so it can not be copied.
// std::function can only store object functions that can be copied.
std::unique_function&lt;int(int, int)>
make_random_generator(std::unique_ptr&lt;std::mt19937>&& producer) {
    return [producer = std::move(producer)] (int min, int max) {
        std::uniform_int_distribution dis(min, max);
        return dis(*producer);
    }
}
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>make_overload<!--**--></h3>
								<!--h4>Exercise</h4-->
									Write a function that takes an arbitrary number of <em>function objects</em> as parameters, and returns a <em>function object</em> that provides all the operators <code class = "language-cpp">()</code> of the parameters.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">auto os = std::ofstream{ "logs.txt" };
auto elements = std::tuple{ 42, "hello" };
​
auto f = make_overload(
    [&os] (int i)           { os << "int = " << i; },
    [&os] (char const* str) { os << "str = " << str; }
);
f(std::get<0>(elements)); // int = 42
f(std::get<1>(elements)); // str = hello
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>thread_pool<!--**--></h3>
								<!--h4>Exercise</h4-->
									Make a thread pool: it stores threads that it wakes up when tasks to execute are passed.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">// Create the thread pool with its number of threads.
thread_pool threads(2);
​
for (int i = 1; i <= 4; ++i) {
    threads.enqueue([i] {
        using namespace std::chrono_literals;
        std::this_thread::sleep(1s);
        std::cout << "task " << i << " finished\n";
    });
}
// A second passes ...
// task 1 finished
// task 2 finished
// A second passes ...
// task 3 finished
// task 4 finished
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>ring_buffer<!--**--></h3>
								<!--h4>Exercise</h4-->
									Make a <em>lock-free</em> ring buffer: it must allow one thread to add values and one another to remove values. Write the changes that are needed to allow multiple producers or multiple consumers at the same time.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">// Create the ring buffer with its capacity.
ring_buffer&lt;std::string> buffer(128);
​
auto producer = std::async([&] {
    buffer.emplace("hello ");
    buffer.emplace("world");
});
auto consumer = std::aync([&] {
    std::cout << buffer.pop() << buffer.pop();
});
producer.get();
consumer.get();
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>is_iterable, is_iterator<!--**--></h3>
								<!--h4>Exercise</h4-->
									Write <code class="language-cpp">is_iterator&lt;T></code> and <code class="language-cpp">is_iterable&lt;T></code>.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">static_assert(!is_iterator&lt;int>);
static_assert( is_iterator&lt;int*>);
static_assert(!is_iterable&lt;int*>);
static_assert( is_iterable&lt;std::list&lt;int>>);
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>nth_times<!--*--></h3>
								<!--h4>Exercise</h4-->
									Write the template function <code class = "language-cpp">nth_times</code> that executes a <em>function object</em> N times. No loop should be used: <code class = "language-cpp">nth_times <200>(f)</code> will copy the call to <code class = "language-cpp">f</code> 200 times.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">void execute();
​
int main() {
    nth_times<5>(execute);
    // Equivalent to:
    // execute();
    // execute();
    // execute();
    // execute();
    // execute();
}
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>alloca_aligned<!--*--></h3>
								<!--h4>Exercise</h4-->
									Write a macro <code class = "language-cpp">alloca_aligned(nb, align)</code> that allocates <code class = "language-cpp">nb</code> bytes on the stack, with the required alignment. Explain why a function can not be used instead.<br> Example of use:

<pre class="line-numbers"><code class="language-cpp">template &lt;class T>
bool test(int nb) {
    // Allocates nb objets of type T on the stack.
    auto ptr = alloca_aligned(nb * sizeof(T), alignof(T));
    // Returns 'true' if the allocation is aligned.
    auto address = reinterpret_cast&lt;uintptr_t>(ptr);
    return address % alignof(T) == 0;
}
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
							<h3>block_allocator<!--**--></h3>
								<!--h4>Exercise</h4-->
									Make a <em>block allocator</em> respecting the standard concept of allocator to be able to use it with a container of the standard library, and allow the resource used (containing the blocks) to allocate new blocks if none are available.<br>
									Example of use:

<pre class="line-numbers"><code class="language-cpp">std::list&lt;int, block_allocator&lt;int>>
make_list(block_ressource&lt;MySize, MyAlign>& resource) {
    auto list = std::list&lt;int, block_allocator&lt;int>>(resource.make_allocator());
    list.push_back(2);
    list.push_back(3);
    list.push_front(1);
    return list;
}
</code></pre>

								<!--h4>Proposed solution</h4-->
<p></p>
						</p>
					</section>
				</article>

			</div>
		</div>


		<div class="row">
			<div class="12u">

				<!-- Copyright -->
				<div id="copyright">
					<ul class="links">
						<li>&copy; Thomas Caroff 2018. All rights reserved.</li>
						<li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>

			</div>
		</div>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.dropotron.min.js"></script>
	<script src="assets/js/skel.min.js"></script>
	<script src="assets/js/skel-viewport.min.js"></script>
	<script src="assets/js/util.js"></script>
	<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
	<script src="assets/js/main.js"></script>

	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>


</body>

</html>
